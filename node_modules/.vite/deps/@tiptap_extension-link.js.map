{
  "version": 3,
  "sources": ["../../@tiptap/extension-link/src/helpers/autolink.ts", "../../@tiptap/extension-link/src/helpers/clickHandler.ts", "../../@tiptap/extension-link/src/helpers/pasteHandler.ts", "../../@tiptap/extension-link/src/link.ts"],
  "sourcesContent": ["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { MultiToken, tokenize } from 'linkifyjs'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  validate?: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(\n          newState.doc,\n          newRange,\n          node => node.isTextblock,\n        )\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject())\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(\n                link.from,\n                link.to,\n                newState.schema.marks.code,\n              )\n            })\n            // validate link\n            .filter(link => {\n              if (options.validate) {\n                return options.validate(link.value)\n              }\n              return true\n            })\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n", "import { getAttributes } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType,\n  whenNotEditable: boolean,\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (options.whenNotEditable && view.editable) {\n          return false\n        }\n        if (event.button !== 0) {\n          return false\n        }\n\n        let a = event.target as HTMLElement\n        const els = []\n\n        while (a.nodeName !== 'DIV') {\n          els.push(a)\n          a = a.parentNode as HTMLElement\n        }\n\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false\n        }\n\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLLinkElement)\n\n        const href = link?.href ?? attrs.href\n        const target = link?.target ?? attrs.target\n\n        if (link && href) {\n          window.open(href, target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n", "import { Editor } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  type: MarkType\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n", "import {\n  Mark, markPasteRule, mergeAttributes, PasteRuleMatch,\n} from '@tiptap/core'\nimport { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string;\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean;\n}\n\nexport const pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   * @example 'whenNotEditable'\n   */\n  openOnClick: boolean | 'whenNotEditable'\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate?: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: { href: string; target?: string | null; rel?: string | null; class?: string | null }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes: { href: string; target?: string | null; rel?: string | null; class?: string | null }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{ tag: 'a[href]:not([href *= \"javascript:\" i])' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // False positive; we're explicitly checking for javascript: links to ignore them\n    // eslint-disable-next-line no-script-url\n    if (HTMLAttributes.href?.startsWith('javascript:')) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes => ({ chain }) => {\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes => ({ chain }) => {\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () => ({ chain }) => {\n          return chain()\n            .unsetMark(this.name, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const links = find(text).filter(item => item.isLink)\n\n            if (links.length) {\n              links.forEach(link => (foundLinks.push({\n                text: link.value,\n                data: {\n                  href: link.href,\n                },\n                index: link.start,\n              })))\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          validate: this.options.validate,\n        }),\n      )\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n          whenNotEditable: this.options.openOnClick === 'whenNotEditable',\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          type: this.type,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n"],
  "mappings": "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",
  "names": []
}
